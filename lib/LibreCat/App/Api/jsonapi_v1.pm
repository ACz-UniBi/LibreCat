package LibreCat::App::Api::jsonapi_v1;

use Catmandu::Sane;
use Catmandu::Util qw(:is);
use Hash::Merge::Simple qw(merge);
use LibreCat -self;
use Dancer qw(:script);
use LibreCat::App::Helper;
use Try::Tiny;
use URI::Escape qw(uri_escape_utf8);

=head1 JSON API v1 for LibreCat models

=head2 Authentication

The JSON API uses two layers of authentication

=head3 IP based authentication

Configure the ip ranges in the Catmandu config at key `api.v1.ip_range`:

    api:
      v1:
        ip_range: [ "157.193.0.0/16" ]

One can always set the ip_range to 0.0.0.0/0 and handle this in the proxy server

or - even better - in the firewall.

=head3 JWT based authentication

Configure JWT secret in the Catmandu config at key 'api.v1.token_secret`:

    api:
      v1:
        token_secret: "areyoureallytryingtoreadthis"

A JWT token can be generated by use of the LibreCat CLI:

    $ ./bin/librecat token encode

A client adds this token as bearer token in the header `Authorization`

    $ curl -H "Authorization:Bear my.jwt.token" "http://localhost:5001/api/v1/publicaton/1"

Possible errors that relate to authentication:

* 401: Authorization required

    {
       "errors" : [
          {
             "title" : "authorization required",
             "status" : "401"
          }
       ]
    }

* 403: Access denied

    {
       "errors" : [
          {
             "title" : "access denied",
             "status" : "403"
          }
       ]
    }

=head2 ROUTES

=head3 POST /api/v1/:model

Create a new record of type :model (e.g. "publication")

The record must be supplied as JSON in the request body.

When successfull, http status 201 is returned and the record

is returned as if you would have called `GET /api/v1/:model/:id` (see below):

    $ token="my.jwt.token"
    $ curl -XPOST "http://localhost:5001/api/v1/publication" -H "Authorization:Bearer $token" -d '{ "title":"test", "status": "new", "type" : "book" }'

    {
       "data" : {
          "links" : {
             "self" : "http://localhost:5001/api/v1/publication/9117"
          },
          "type" : "publication",
          "id" : "9117",
          "attributes" : {
             "type" : "book",
             "title" : "test",
             "date_updated" : "2020-03-12T10:12:46Z",
             "_id" : "9117",
             "date_created" : "2020-03-12T10:12:46Z",
             "status" : "new"
          },
          "relationships" : {
             "versions" : {
                "links" : {
                   "related" : "http://localhost:5001/api/v1/publication/9117/versions"
                }
             }
          }
       }
    }

Possible errors:

* 404: model :model not found

    {
       "errors" : [
          {
             "title" : "model rubbish not found",
             "status" : "404"
          }
       ]
    }

* 404: record :id not found in model :model

    {
       "errors" : [
          {
             "title" : "record 1 not found in model rubbish",
             "status" : "404"
          }
       ]
    }

* 400: malformed json string

    {
       "errors" : [
          {
             "status" : "400",
             "title" : "malformed JSON string"
          }
       ]
    }

* 400: validation error

    {
       "errors" : [
          {
             "source" : {
                "pointer" : "/type"
             },
             "title" : "type is required",
             "code" : "object.required",
             "status" : "400"
          }
       ]
    }

=head3 GET /api/v1/:model/:id

Retrieve record :id of model :model.

Status code is either 200 or 404:

    {
       "data" : {
          "links" : {
             "self" : "http://localhost:5001/api/v1/publication/9117"
          },
          "type" : "publication",
          "id" : "9117",
          "attributes" : {
             "type" : "book",
             "title" : "test",
             "date_updated" : "2020-03-12T10:12:46Z",
             "_id" : "9117",
             "date_created" : "2020-03-12T10:12:46Z",
             "status" : "new"
          },
          "relationships" : {
             "versions" : {
                "links" : {
                   "related" : "http://localhost:5001/api/v1/publication/9117/versions"
                }
             }
          }
       }
    }

When applicable the response includes a link to the versions.

=head3 DELETE /api/v1/:model/:id

Delete record :id of model :id.

Status code is either 200 or 404:

    {
       "data" : {
          "attributes" : {
             "status" : "deleted"
          },
          "id" : "9117",
          "type" : "publication",
          "links" : {
             "self" : "http://localhost:5001/api/v1/publication/9117"
          }
       }
    }

Note that a "delete" in LibreCat does not actually delete a record.

The status is simply set to "deleted", so you can still do actions on this record in the json api.

=head3 PUT /api/v1/:model/:id

Fully overwrite record :id of model :model.

Same response as the route "POST /api/v1/:model"

Additional errors:

* 403: access denied

This happens when you supply the attribute "file" in your record:

    {
       "errors" : [
          {
             "title" : "Forbidden to update attribute file in this route",
             "source" : {
                "pointer" : "/file"
             },
             "status" : "403"
          }
       ]
    }

=head3 PATCH /api/v1/:model/:id

Only update certain fields of record :id in model :model.

These new fields are (deeply) merged into the old record.

Note that a deep merge only works for hashes. An array is always

completely overwritten.

Same response and errors as the route "PUT /api/v1/:model"

=head3 GET /api/v1/:model/:id/versions

Retrieve older versions of record :id of model :model.

Only a short description and a link to the full record is supplied.

Status code and errors are the same as for `GET /api/v1/:model/:id`.

Response:

    {
       "data" : [
          {
             "links" : {
                "self" : "http://localhost:5001/api/v1/publication/9117/versions/3"
             },
             "type" : "publication",
             "id" : "9117",
             "attributes" : {
                "_version" : 3,
                "_id" : "9117"
             }
          },
          {
             "id" : "9117",
             "attributes" : {
                "_version" : 2,
                "_id" : "9117"
             },
             "links" : {
                "self" : "http://localhost:5001/api/v1/publication/9117/versions/2"
             },
             "type" : "publication"
          },
          {
             "type" : "publication",
             "links" : {
                "self" : "http://localhost:5001/api/v1/publication/9117/versions/1"
             },
             "attributes" : {
                "_id" : "9117",
                "_version" : 1
             },
             "id" : "9117"
          }
       ]
    }

Additional errors:

* 400: versioning not configured for model :model

    {
       "errors" : [
          {
             "title" : "no versioning is enabled for model department",
             "status" : "400"
          }
       ]
    }


=head3 GET /api/v1/:model/:id/versions/:version

Same http status, response and errors as for route `GET /api/v1/:model/:id`.

Additional errors:

* 400: versioning not configured for model :model

    {
       "errors" : [
          {
             "title" : "no versioning is enabled for model department",
             "status" : "400"
          }
       ]
    }

=cut

# /api/v1
hook before => sub {

    my $request     = request();
    my $env         = $request->env();
    my $path_info   = $request->path_info();

    if( index( $path_info,"/api/v1" ) == 0 ){

        #disable storing of sessions for /api/v1
        #note that the cookie is still sent
        $env->{"psgix.session.options"} //= {};
        $env->{"psgix.session.options"}->{no_store} = 1;

        if(
            $path_info ne "/api/v1/_access_denied" &&
            $path_info ne "/api/v1/_authorization_required"
        ){

            #ip access denied: 403
            unless(
                h->within_ip_range(
                    $request->address(),
                    ip_ranges()
                )
            ){

                #the only to stop the current request is to change the path to another route
                return $request->path_info( "/api/v1/_access_denied" );

            }

            #jwt authentication
            my $auth = $request->header( "Authorization" );
            unless( is_string( $auth ) ){

                return $request->path_info( "/api/v1/_authorization_required" );

            }

            my($bearer,$token) = split( /\s+/o, $auth );

            unless(
                is_string( $bearer ) &&
                is_string( $token ) &&
                lc( $bearer ) eq "bearer" &&
                librecat->token->decode( $token )
            ){

                return $request->path_info( "/api/v1/_access_denied" );

            }

        }

    }

};

prefix "/api/v1" => sub {

    #routes for internal use.
    any "/_access_denied" => sub {

        json_errors(
            403,
            [ { status => "403", title => "access denied" } ]
        );

    };

    any "/_authorization_required" => sub {

        json_errors(
            401,
            [ { status => "401", title => "authorization required" } ]
        );

    };

    # GET /api/v1/:model/:id
    get "/:model/:id" => sub {

        show_model_record( params("route") );

    };

    # DELETE /api/v1/:model/:id
    del "/:model/:id" => sub {

        delete_model_record( params("route") );

    };

    # PUT /api/v1/:model/:id
    put "/:model/:id" => sub {

        update_model_record( params("route") );

    };

    # PATCH /api/v1/:model/:id
    patch "/:model/:id" => sub {

        patch_model_record( params("route") );

    };

    # POST /api/v1/:model
    post "/:model" => sub{

        create_model_record( params("route") );

    };

    # GET /api/v1/:model/versions
    get "/:model/:id/versions" => sub {

        show_model_record_history( params("route") );

    };

    # GET /api/v1/:model/versions/:version
    get "/:model/:id/versions/:version" => sub {

        show_model_version( params("route") );

    };


    # catch all route for /api/v1
    any qr(.*) => sub {

        not_found( title => "route not found" );

    };

};

sub show_model_record {

    my(%args) = @_;

    my $model = delete $args{model};
    my $id    = delete $args{id};

    my $recs  = librecat->model( $model ) // return not_found( title => "model $model not found" );
    my $rec   = $recs->get( $id ) // return not_found( title => "record $id not found in model $model" );
    my $req   = request();
    my $self_uri = $req->uri_for( $req->path_info() )->as_string();
    my $data = {
        type       => $model,
        id         => $id,
        attributes => $rec,
        links      => { self => $self_uri },
    };

    if( $recs->does("LibreCat::Model::Plugin::Versioning") ){

        $data->{relationships} = {
            versions => {
                links => {
                    related => "${self_uri}/versions"
                }
            }
        };

    }

    content_type "application/json";
    to_json({ data => $data });

}

sub create_model_record {

    my(%args) = @_;

    my $model = delete $args{model};
    my $id    = delete $args{id};

    my $recs  = librecat->model( $model ) // return not_found( title => "model $model not found" );
    my $data;
    my $parse_error;
    my $req   = request();

    try {

        $data = from_json( $req->body() );

    }catch {

        $parse_error = $_;

    };

    return json_not_valid() if defined( $parse_error );

    #do not accept attribute "file" for model "publication"
    if( $model eq "publication" ){

        if( exists( $data->{file} ) ){

            return json_errors(
                403,
                [{
                    status => "403",
                    title => "Forbidden to update attribute file in this route",
                    source => { pointer => "/file" }
                }]
            );

        }

        $data->{file} = [];

    }

    my $http_content;

    librecat->hook( "jsonapi-$model-create" )->fix_around(
        $data,
        sub {
            $recs->add(
                $data,
                on_validation_error => sub {
                    my ($x, $errors) = @_;
                    $http_content = json_errors(
                        400,
                        [
                            map {
                                # 'file.0.access_level' => '/file/0/access_level'
                                my $pointer = "/" . join( "/",split( /\./o, $_->property() ) );
                                +{
                                    code => $_->code(),
                                    status => "400",
                                    title => $_->localize(),
                                    source => {
                                        pointer => $pointer
                                    }
                                }
                            }
                            @$errors
                        ]
                    );
                },
                on_success => sub {
                    my $self_uri = $req->uri_for( $req->path_info )->as_string()."/".$data->{_id};

                    my $d = {
                        type       => $model,
                        id         => $data->{_id},
                        attributes => $data,
                        links      => { self => $self_uri },
                    };

                    if( $recs->does("LibreCat::Model::Plugin::Versioning") ){

                        $d->{relationships} = {
                            versions => {
                                links => {
                                    related => "${self_uri}/versions"
                                }
                            }
                        };

                    }

                    # send created status 201
                    status 201;
                    content_type "application/json";
                    $http_content = to_json({ data => $d });
                }
            );
        }
    );

    $http_content;

}

sub update_model_record {

    my(%args) = @_;

    my $model = delete $args{model};
    my $id    = delete $args{id};

    my $recs  = librecat->model( $model ) // return not_found( title => "model $model not found" );
    my $data;
    my $parse_error;
    my $req   = request();

    try {

        $data = from_json( $req->body() );

    }catch {

        $parse_error = $_;

    };

    return json_not_valid() if defined( $parse_error );

    my $old_rec = $recs->get( $id );

    # does record exist?
    unless( $old_rec ){
        return not_found( title => "record $id not found in model $model" );
    }

    # does the record contain an id and does it match the given id
    if( $data->{_id} ){
        if( $data->{_id} eq $id ){
            # ok
        }
        else {
            return json_errors(
                400,
                [{ status => "400", title => "id in request and data do not match" }]
            );
        }
    }
    else {
        $data->{_id} = $id;
    }

    #update of attribute file forbidden for model publication
    if( $model eq "publication" ){

        if( exists( $data->{file} ) ){

            return json_errors(
                403,
                [{
                    status => "403",
                    title => "Forbidden to update attribute file in this route",
                    source => { pointer => "/file" }
                }]
            );

        }
        $data->{file} = $old_rec->{file} // [];

    }

    my $http_content;

    librecat->hook( "jsonapi-$model-update" )->fix_around(
        $data,
        sub {
            $recs->add(
                $data,
                on_validation_error => sub {
                    my ($x, $errors) = @_;
                    $http_content = json_errors(
                        400,
                        [
                            map {
                                # 'file.0.access_level' => '/file/0/access_level'
                                my $pointer = "/" . join( "/",split( /\./o, $_->property() ) );
                                +{
                                    code => $_->code(),
                                    status => "400",
                                    title => $_->localize(),
                                    source => {
                                        pointer => $pointer
                                    }
                                }
                            }
                            @$errors
                        ]
                    );
                },
                on_success => sub {
                    my $self_uri = $req->uri_for( $req->path_info() )->as_string();

                    my $d = {
                        type       => $model,
                        id         => $data->{_id},
                        attributes => $data,
                        links      => { self => $self_uri }
                    };

                    if( $recs->does("LibreCat::Model::Plugin::Versioning") ){

                        $d->{relationships} = {
                            versions => {
                                links => {
                                    related => "${self_uri}/versions"
                                }
                            }
                        };

                    }

                    status 200;
                    content_type "application/json";
                    $http_content = to_json({ data => $d });
                }
            );
        }
    );

    $http_content;

}

sub patch_model_record {

    my(%args) = @_;

    my $model = delete $args{model};
    my $id    = delete $args{id};

    my $recs  = librecat->model( $model ) // return not_found( title => "model $model not found" );
    my $data;
    my $parse_error;
    my $req   = request();

    try {

        $data = from_json( $req->body() );

    }catch {

        $parse_error = $_;

    };

    return json_not_valid() if defined( $parse_error );

    my $old_rec = $recs->get( $id );

    # does record exist?
    unless( $old_rec ){
        return not_found( title => "record $id not found in model $model" );
    }

    # does the record contain an id and does it match the given id
    if( $data->{_id} ){
        if( $data->{_id} eq $id ){
            # ok
        }
        else {
            return json_errors(
                400,
                [{ status => "400", title => "id in request and data do not match" }]
            );
        }
    }
    else {
        # ok we are not updating the id
    }

    #update of attribute file forbidden
    if( $model eq "publication" ){

        if( exists( $data->{file} ) ){

            return json_errors(
                403,
                [{
                    status => "403",
                    title => "Forbidden to update attribute file in this route",
                    source => { pointer => "/file" }
                }]
            );

        }

    }

    $data = merge( $old_rec, $data );

    my $http_content;

    librecat->hook( "jsonapi-$model-patch" )->fix_around(
        $data,
        sub {
            $recs->add(
                $data,
                on_validation_error => sub {
                    my ($x, $errors) = @_;
                    $http_content = json_errors(
                        400,
                        [
                            map {
                                # 'file.0.access_level' => '/file/0/access_level'
                                my $pointer = "/".join("/",split( /\./o, $_->property() ));
                                +{
                                    code => $_->code(),
                                    status => "400",
                                    title => $_->localize(),
                                    source => {
                                        pointer => $pointer
                                    }
                                }
                            }
                            @$errors
                        ]
                    );
                },
                on_success => sub {
                    my $self_uri = $req->uri_for( $req->path_info() )->as_string();

                    my $d = {
                        type       => $model,
                        id         => $data->{_id},
                        attributes => $data,
                        links      => { self => $self_uri },
                    };

                    if( $recs->does("LibreCat::Model::Plugin::Versioning") ){

                        $d->{relationships} = {
                            versions => {
                                links => {
                                    related => "${self_uri}/versions"
                                }
                            }
                        };

                    }

                    status 200;
                    content_type "application/json";
                    $http_content = to_json({ data => $d });
                }
            );
        }
    );

    $http_content;

}

sub delete_model_record {

    my(%args) = @_;

    my $model = delete $args{model};
    my $id    = delete $args{id};

    my $recs  = librecat->model($model) // return not_found( title => "model $model not found" );
    my $rec   = $recs->get( $id ) // return not_found( title => "record $id not found in model $model" );
    my $req   = request();

    librecat->hook("jsonapi-$model-delete")->fix_around(
        $rec,
        sub {
            $recs->delete($id);
        }
    );

    my $data = {
        type       => $model,
        id         => $id,
        attributes => { status => "deleted" },
        links      => { self => $req->uri_for( $req->path_info() )->as_string() },
    };

    content_type "application/json";
    to_json({ data => $data });

}

sub show_model_record_history {

    my(%args) = @_;

    my $model = delete $args{model};
    my $id    = delete $args{id};

    my $recs  = librecat->model( $model ) // return not_found( title => "model $model not found" );

    # history not supported for this model
    unless( $recs->does("LibreCat::Model::Plugin::Versioning") ){

        return json_errors(
            400,
            [{ status => "400", title => "no versioning is enabled for model $model" }]
        );

    }

    my $versions = $recs->get_history( $id ) // return not_found( title => "record $id not found in model $model" );
    my $req = request();
    my $parent_uri_base = $req->uri_for( $req->path_info() )->as_string();
    my $data = [
        map {

            +{
                type => $model,
                id => $_->{_id},
                attributes => {
                    _id => $_->{_id},
                    _version => $_->{_version}
                },
                links => {
                    self => "${parent_uri_base}/".$_->{_version}
                }
            };

        } @$versions
    ];

    status 200;
    content_type "application/json";
    to_json({ data => $data });

}

sub show_model_version {

    my(%args) = @_;

    my $model   = delete $args{model};
    my $id      = delete $args{id};
    my $version = delete $args{version};

    my $recs    = librecat->model( $model ) // return not_found( title => "model $model not found" );

    # history not supported for this model
    unless( $recs->does("LibreCat::Model::Plugin::Versioning") ){

        return json_errors(
            400,
            [{ status => "400", title => "no versioning is enabled for model $model" }]
        );

    }

    my $rec     = $recs->get_version( $id, $version ) // return not_found( title => "version $version not found for record $id of model $model" );
    my $req     = request();
    my $data    = {
        type       => $model,
        id         => $id,
        attributes => $rec,
        links      => { self => $req->uri_for( $req->path_info() )->as_string() },
    };

    status 200;
    content_type "application/json";
    to_json({ data => $data });

}

sub not_found {

    my(%args) = @_;

    json_errors(
        404,
        [ { status => "404", title => $args{title} } ]
    );

}

sub json_not_valid {

    json_errors(
        400,
        [ { status => "400", title => "malformed JSON string" } ]
    );

}

# cf. https://jsonapi.org/format/#error-objects
sub json_errors {

    my($status,$errors) = @_;

    status $status;
    content_type "application/json";
    to_json({ errors => $errors });

}

sub ip_ranges {

    state $i = do {
        my $ip_range = librecat->config->{api}->{v1}->{ip_range};
        is_array_ref( $ip_range ) ? $ip_range : [];
    };

}

1;

__END__

=pod

=head1 NAME

LibreCat::Controller::ModelApi - a model api controller

=head1 SYNOPSIS

=head2 SEE ALSO

L<LibreCat>

=cut
